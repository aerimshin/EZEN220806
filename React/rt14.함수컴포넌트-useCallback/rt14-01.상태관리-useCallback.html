<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>

    <link rel="stylesheet" href="../css/reset.css"/>

</head>

<body>

    <xmp>
        React의 컴포넌트 사이에서 데이터를 주고 받는 방법에 대해서 배운다.

        부모가 자식에게 데이터를 전달하는 것은 자식컴포넌트에서 부모컴포넌트의 데이터를 이용한(읽기) 로직을 처리하기 위함이고,
        자식 컴포넌트에서 부모컴포넌트로 데이터를 전달하는 것은 부모 state의 값을 변경하기 위함입니다.

        state down vs state up
        - state down: 부모 -> 자식 데이터 전달
        - state up: 자식 -> 부모 데이터 전달
    </xmp>
    <div>
        <img src="../images/stateupdonw.png" alt="" style="display: inline-block;">
    </div>

    <xmp>
        - 부모 컴포넌트에서 자식 컴포넌트에 함수를 props 로 전달 후,
        - 자식은 해당 함수, props를 통해 받은 함수를 호출해서 자식 데이터를 부모에게 전달하게 된다.

        부모 컴포넌트
        function Parent(props) {
            // 컴포넌트의 상태값 설정
            const [parentText, setParentText] = useState('parent text'); // 상태값이 기본타입인 경우
            const [childMessage, setChildMessage] = useState(null); // 상태값이 기본타입인 경우

            // 콜백 메서드의 연관 배열에는 사용되는 상태명을 기술.
            // 콜백 메서드에서 상태를 한개 사용하면 1개를 적고
            // 콜백 메서드에서 상태를 두개 사용하면 2개를 적으시오.
            const callbackChildText = useCallback( (text)=> {
                console.log(text);
                setChildMessage(text);
                setParentText(text);
            }, [childMessage, parentText] );

            // JSX로 화면 만들기
            return (
                <div>
                    <Child callbackChildText={callbackChildText} parentText={parentText}></Child>
                    <br />
                    {childMessage}
                </div>
            )
        };

        자식 컴포넌트
        function Child(props) {
            // 컴포넌트의 상태값 설정
            const [childText, setChildText] = useState('child text'); // 상태값이 기본타입인 경우

            function handlerChild() {
                props.callbackChildText(childText);
            }

            // JSX로 화면 만들기
            return (
                <div>
                    parentText: {props.parentText}
                    <br />
                    childText: {childText}
                    <br />
                    <button onClick={handlerChild}>button</button>
                </div>
            )
        };

    </xmp>

    <div>
        <img src="../images/react_data_flow.png" style="display: inline-block;">
    </div>

    <hr>

    <div id="app">
    </div>
</body>

</html>


<script src="https://unpkg.com/@babel/standalone/babel.min.js"  crossorigin="anonymous">
    /* 자바스크립트로 컴파일러. ES6-->ES5, JSX-->ES5 */
</script>
<script src="http://unpkg.com/react@17/umd/react.development.js" crossorigin="anonymous">
    /* import React, { Component, PureComponent } from 'react' */
</script>
<script src="http://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin="anonymous">
    /* import ReactDOM from 'react-dom' */
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-redux/7.2.8/react-redux.js" crossorigin="anonymous">
    /*  import ReactRedux, {Provider, useDispatch, useSelector} from 'react-redux' */
</script>
<script src="http://unpkg.com/react-router-dom@6/umd/react-router-dom.development.js" crossorigin="anonymous">
    /*  import ReactRouterDOM, {BrowserRouter, Routes, Route, Link, NavLink, useParams, useLocation, useHistory, useRouteMatch} from 'react-router-dom' */
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.js" crossorigin="anonymous">
</script>
<script type="text/babel">

    const { useState, useEffect, useRef, useCallback, useMemo, useReducer, Fragment } = React;

    // Child 컴포넌트 만들기
    function Child({ parentText }) {
      // redux store 와 연동되는 경우에만 useDispatch(), useSelector() 사용
      // const dispatch = useDispatch();
      // const { error, isLoading, notis } = useSelector( state => state.notis );


      // 페이지에 대한 경로와 query-string 정보를 추출하는 경우 useLocation() 훅 사용
      // const { pathname, search } = useLocation();

      // path 변수를 추출하는 경우 useParams() 사용. id === match.params.id */
      // const { id } = useParams();

      // 이전 경로 useHistory() 사용 */
      // const history = useHistory();


      // useState 를 사용한 컴포넌트의 상태값 설정
      const [변수명, set변수명] = useState('기본값'); // 상태값이 기본타입인 경우
      const [state, setState] = useState({ id: 0, name: '', age: 0, }); // 상태값이 참조타입 경우

      // useReducer 를 사용한 컴포넌트의 상태값 설정. 리듀서는 현재 상태를 받아서 새 상태를 반환하는 함수다
      const [리듀서, set리듀서] = useReducer((oldvalue, newvalue)=>({...oldvalue, ...newvalue}), { id: 0, name: '', age: 0, }); // 리듀서(reducer) 방식의 상태값 설정

      // ref 만들기.
      // const refInput = useRef();

      // refIsMounted는 생명주기의 마운트와 업데이트를 구분하기 위한 ref
      const refIsMounted = useRef(false);
      useEffect( () => {
        if (refIsMounted.current){
          // 업데이트 될 때마다 실행됨. 여러번. state 가 변경될 때마다
          // console.log('Child >> componentDidUpdate');
        }
        else {
          // 마운트 완료 후에 실행됨. 한번만. focus 줄때
          // console.log('Child >> componentDidMount');
          refIsMounted.current = true;
        }
        return () => {
          // 언마운트 직전에 한번만 실행됨.
          // console.log('Child >> componentWillUmount');
        };
      }, [/* 조건 제어: 메서드와 연관되는 상태(변수)명들을 기술 */]);

      // callback 메서드 작성. callback 메서드는 부모의 공유 상태값을 변경하기 위해서 사용된다.
      const callback = useCallback( (param)=>{
        // state 변경
      }, [/* 조건 제어: 메서드와 연관되는 상태(변수)명들을 기술 */]);

      // 이벤트 핸들러 작성.
      const handler = ()=>{
        // 이벤트 핸들러는 화살표 함수로 만든다
        console.log(window.event.target);
      };

      // JSX로 화면 만들기
      return (
        <div>
            parentText: {parentText}
            <br />
            childText: {childText}
            <br />
            <button onClick={handlerChild}>button</button>
        </div>
      )
    }

    Child.propTypes = {
      // props의 프로퍼티 타입 설정. https://ko.reactjs.org/docs/typechecking-with-proptypes.html
      // 인자명: PropTypes.func.isRequired,
      parentText: PropTypes.string.isRequired,
    };
    Child.defaultProps = {
      // props의 디폴트 값 설정. https://ko.reactjs.org/docs/typechecking-with-proptypes.html
      // 인자명: () => {},
      parentText: '',
    };

    // Parent 컴포넌트 만들기
    function Parent({
      ...props
    }) {
      // redux store 와 연동되는 경우에만 useDispatch(), useSelector() 사용
      // const dispatch = useDispatch();
      // const { error, isLoading, notis } = useSelector( state => state.notis );


      // 페이지에 대한 경로와 query-string 정보를 추출하는 경우 useLocation() 훅 사용
      // const { pathname, search } = useLocation();

      // path 변수를 추출하는 경우 useParams() 사용. id === match.params.id */
      // const { id } = useParams();

      // 이전 경로 useHistory() 사용 */
      // const history = useHistory();


      // useState 를 사용한 컴포넌트의 상태값 설정
      const [변수명, set변수명] = useState('기본값'); // 상태값이 기본타입인 경우
      const [state, setState] = useState({ id: 0, name: '', age: 0, }); // 상태값이 참조타입 경우

      // useReducer 를 사용한 컴포넌트의 상태값 설정. 리듀서는 현재 상태를 받아서 새 상태를 반환하는 함수다
      const [리듀서, set리듀서] = useReducer((oldvalue, newvalue)=>({...oldvalue, ...newvalue}), { id: 0, name: '', age: 0, }); // 리듀서(reducer) 방식의 상태값 설정

      // ref 만들기.
      // const refInput = useRef();

      // refIsMounted는 생명주기의 마운트와 업데이트를 구분하기 위한 ref
      const refIsMounted = useRef(false);
      useEffect( () => {
        if (refIsMounted.current){
          // 업데이트 될 때마다 실행됨. 여러번. state 가 변경될 때마다
          // console.log('Parent >> componentDidUpdate');
        }
        else {
          // 마운트 완료 후에 실행됨. 한번만. focus 줄때
          // console.log('Parent >> componentDidMount');
          refIsMounted.current = true;
        }
        return () => {
          // 언마운트 직전에 한번만 실행됨.
          // console.log('Parent >> componentWillUmount');
        };
      }, [/* 조건 제어: 메서드와 연관되는 상태(변수)명들을 기술 */]);

      // callback 메서드 작성. callback 메서드는 부모의 공유 상태값을 변경하기 위해서 사용된다.
      const callback = useCallback( (param)=>{
        // state 변경
      }, [/* 조건 제어: 메서드와 연관되는 상태(변수)명들을 기술 */]);

      // 이벤트 핸들러 작성.
      const handler = ()=>{
        // 이벤트 핸들러는 화살표 함수로 만든다
        console.log(window.event.target);
      };

      // JSX로 화면 만들기
      return (
        <div>
          Parent
        </div>
      )
    }

    Parent.propTypes = {
      // props의 프로퍼티 타입 설정. https://ko.reactjs.org/docs/typechecking-with-proptypes.html
      // 인자명: PropTypes.func.isRequired,
    };
    Parent.defaultProps = {
      // props의 디폴트 값 설정. https://ko.reactjs.org/docs/typechecking-with-proptypes.html
      // 인자명: () => {},
    };

    ReactDOM.render(<Parent />, document.getElementById('app'));
</script>





